>>> print("Module 2: Advanced Data structures & control flow")
Module 2: Advanced Data structures & control flow
>>> print("="*60)
============================================================
>>> print("I'm Python. Nice to meet you!")
I'm Python. Nice to meet you!
>>> print("Hello,World", end="!")
>>> o,World!
>>> input_string_var = input("Enter some data:")
Enter some data:Returns the data as a string
>>> some_var=5
>>> some_var
5
>>> some_unknown_var
Traceback (most recent call last):
  File "<python-input-5>", line 1, in <module>
    some_unknown_var
NameError: name 'some_unknown_var' is not defined
>>> "yay!" if 0 > 1 else "nay!"
'nay!'
>>> li=[]
>>> other_li=[4,5,6]
>>> li.append(1)
>>> li.append(2)
>>> li.append(4)
>>> li.append(3)
>>> li.pop()
3
>>> li.append(3)
>>> li[0]
1
>>> li[-1]
3
>>> li[4]
Traceback (most recent call last):
  File "<python-input-17>", line 1, in <module>
    li[4]
    ~~^^^
IndexError: list index out of range
>>> li[1:3]
[2, 4]
>>> li[2:]
[4, 3]
>>> li[:3]
[1, 2, 4]
>>> li[::2]
[1, 4]
>>> li[::-1]
[3, 4, 2, 1]
>>> li2 = li[:]
>>> del li[2]
>>> li.remove(2)
>>> li.remove(2)
Traceback (most recent call last):
  File "<python-input-27>", line 1, in <module>
    li.remove(2)
    ~~~~~~~~~^^^
ValueError: list.remove(x): x not in list
>>> li.insert(1,2)
>>> li.index(2)
1
>>> li.index(4)
Traceback (most recent call last):
  File "<python-input-30>", line 1, in <module>
    li.index(4)
    ~~~~~~~~^^^
ValueError: 4 is not in list
>>> li + other_li
[1, 2, 3, 4, 5, 6]
>>> li.extend(other_li)
>>> 1 in li
True
>>> len(li)
6
>>> tup = (1,2,3)
>>> tup[0]
1
>>> tup[0] = 3
Traceback (most recent call last):
  File "<python-input-37>", line 1, in <module>
    tup[0] = 3
    ~~~^^^
TypeError: 'tuple' object does not support item assignment
>>> type((1))
<class 'int'>
>>> type((1,))
<class 'tuple'>
>>> type(())
<class 'tuple'>
>>> len(tup)
3
>>> tup+(4,5,6)
(1, 2, 3, 4, 5, 6)
>>> tup[:2]
(1, 2)
>>> 2 in tup
True
>>> a,b,c=(1,2,3)
>>> a,*b,c=(1,2,3,4)
>>> d,e,f=4,5,6
>>> e,d=d,e
>>> empty_dict={}
>>> filled_dict={"one":1, "two":2, "three":3}
>>> invalid_dict={[1,2,3]:"123"}
Traceback (most recent call last):
  File "<python-input-16>", line 1, in <module>
    invalid_dict={[1,2,3]:"123"}
                 ^^^^^^^^^^^^^^^
TypeError: unhashable type: 'list'
>>> valid_dict={(1,2,3):[1,2,3]}
>>> filled_dict["one"]
1
>>> list(filled_dict.keys())
['one', 'two', 'three']
>>> list(filled_dict.values())
[1, 2, 3]
>>> "one" in filled_dict
True
>>> 1 in filled_dict
False
>>> filled_dict["four"]
Traceback (most recent call last):
  File "<python-input-24>", line 1, in <module>
    filled_dict["four"]
    ~~~~~~~~~~~^^^^^^^^
KeyError: 'four'
>>> filled_dict.get("one")
1
>>> filled_dict.get("four")
>>>
>>> filled_dict.get("one",4)
1
>>> filled_dict.get("four",4)
4
>>> filled_dict.setdefault("five",5)
5
>>> filled_dict.setdefault("five",6)
5
>>> filled_dict.update({"four":4})
>>> filled_dict["four"]=4
>>> del filled_dict["one"]
>>> {"a":1, **{"b":2}}
{'a': 1, 'b': 2}
>>> {"a":1,**{"a":2}}
{'a': 2}
>>> empty_set=set()
>>> some_set={1,1,2,2,3,4}
>>> invalid_set={[1],1}
Traceback (most recent call last):
  File "<python-input-40>", line 1, in <module>
    invalid_set={[1],1}
                ^^^^^^^
TypeError: unhashable type: 'list'
>>> valid_set={(1,),1}
>>> filled_set=some_set
>>> filled_set.add(5)
>>> filled_set.add(5)
>>> other_set={3,4,5,6}
>>> filled_set&other_set
{3, 4, 5}
>>> filled_set | other_set
{1, 2, 3, 4, 5, 6}
>>> {1,2,3,4}-{2,3,5}
{1, 4}
>>> {1,2,3,4} ^ {2,3,5}
{1, 4, 5}
>>> {1,2} >= {1,2,3}
False
>>> {1,2} <= {1,2,3}
True
>>> 2 in filled_set
True
>>> 10 in filled_set
False
>>> filled_set = some_set.copy()
>>> filled_set is some_set
False

ADVANCED COLLECTION OPERATIONS
>>> print("\n"+"="*60)

============================================================
>>> print("ADVANCED COLLECTION OPERATIONS")
ADVANCED COLLECTION OPERATIONS
>>> print("="*60)
============================================================
1.LIST COMPREHENSIONS
>>> print("\n1. List Comprehensions:")

1. List Comprehensions:
>>> print("-"*40)
----------------------------------------
>>> squares=[x**2 for x in range(10)]
>>> print(f"Squares: {squares}")
Squares: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> even_squares = [x**2 for x in range(10) if x%2==0]
>>> print(f"Even Squares: {even_squares}")
Even Squares: [0, 4, 16, 36, 64]
>>> matrix=[[i+j for j in range(3)]for i in range(3)]
>>> print(f"Matrix: {matrix}")
Matrix: [[0, 1, 2], [1, 2, 3], [2, 3, 4]]
>>> print("\n2.Dictionary Comprehensions:")

2.Dictionary Comprehensions:
>>> print("-"*40)
----------------------------------------
>>> square_dict={x:x**2 for x in range(5)}
>>> print(f"Square dictionary: {square_dict}")
Square dictionary: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
>>> even_square_dict={x: x**2 for x in range(10) if x % 2 == 0}
>>> print(f"Eve square dictionary: {even_square_dict}")
Eve square dictionary: {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
>>> print("\n3.Set Comprehensions:")

3.Set Comprehensions:
>>> print("-"*40)
----------------------------------------
>>> unique_lengths={len(word) for word in ["hello","world","python","code"]}
>>> print(f"Unique word lengths: {unique_lengths}")
Unique word lengths: {4, 5, 6}

STRING MANIPULATION AND FORMATTING
>>> print("\n" + "="*60)

============================================================
>>> print("STRING MANIPULATION AND FORMATTING")
STRING MANIPULATION AND FORMATTING
>>> print("="*60)
============================================================

>>> print("\n1. String Methods:")

1. String Methods:
>>> print("-"*40)
----------------------------------------
>>> text="Hello, World!"
>>> print(f"Original: '{text}'")
Original: 'Hello, World!'
>>> print(f"Strip: '{text.strip()}'")
Strip: 'Hello, World!'
>>> print(f"Lower: '{text.lower()}'")
Lower: 'hello, world!'
>>> print(f"Upper: '{text.upper()}'")
Upper: 'HELLO, WORLD!'
>>> print(f"Replace: '{text.replace('World', 'Python')}'")
Replace: 'Hello, Python!'
>>> print(f"Split: {text.split(',')}")
Split: ['Hello', ' World!']
>>> print(f"Startswith 'Hello': {text.strip().startswith('Hello')}")
Startswith 'Hello': True
>>> print(f"Endswith '!': {text.strip().endswith('!')}")
Endswith '!': True

>>> print("\n2. String Formatting:")

2. String Formatting:
>>> print("-"*40)
----------------------------------------
>>> name="Alice"
>>> age=25
>>> score=87.5
>>> print(f"f-string: {name} is {age} years old and scored {score:.1f}%")
f-string: Alice is 25 years old and scored 87.5%
>>> print("format(): {} is {} years old and scored {:.1f}%".format(name,age,score))
format(): Alice is 25 years old and scored 87.5%
>>> print("% formatting: %s is %d years old and scored %.1f%%" % (name,age,score))
Traceback (most recent call last):
  File "<python-input-110>", line 1, in <module>
    print("% formatting: %s is %d years old and scored %.1f%%" % (name,age,score))
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~
TypeError: must be real number, not str

>>> print("\n3.String Joining:")

3.String Joining:
>>> print("-"*40)
----------------------------------------
>>> words=["Python","is","awesome","for","data","science"]
>>> sentence=" ".join(words)
>>> print(f"Joined: {sentence}")
Joined: Python is awesome for data science
>>> csv_line=",".join(["Alice","25","87.5","Computer Science"])
>>> print(f"CSV format: {csv_line}")
CSV format: Alice,25,87.5,Computer Science

CONTROL FLOW WITH COLLECTIONS
>>> print("\n"+"="*60)

============================================================
>>> print("CONTROL FLOW WITH COLLECTIONS")
CONTROL FLOW WITH COLLECTIONS
>>> print("="*60)
============================================================

>>> print("\n1.Conditional Expressions:")

1.Conditional Expressions:
>>> print("-"*40)
----------------------------------------
>>> numbers=[1,2,3,4,5,6,7,8,9,10]
>>> even_numbers=[x for x in numbers if x % 2 == 0]
>>> odd_numbers=[x for x in numbers if x % 2 != 0]
>>> print(f"Even Numbers: {even_numbers}")
Even Numbers: [2, 4, 6, 8, 10]
>>> print(f"Odd Numbers: {odd_numbers}")
Odd Numbers: [1, 3, 5, 7, 9]
>>> filtered_numbers=[x for x in numbers if x > 3 and x < 8]
>>> print(f"Numbers between 3 and 8: {filtered_numbers}")
Numbers between 3 and 8: [4, 5, 6, 7]

>>> print("\n2.Nested Operations:")

2.Nested Operations:
>>> print("-"*40)
----------------------------------------
>>> nested_list=[[1,2,3], [4,5,6], [7,8,9]]
>>> flattened=[item for sublist in nested_list for item in sublist]
>>> print(f"Nested List: {nested_list}")
Nested List: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> print(f"Flattened: {flattened}")
Flattened: [1, 2, 3, 4, 5, 6, 7, 8, 9]

PRACTICAL EXAMPLES
>>> print("\n" + "="*60)

============================================================
>>> print("PRACTICAL EXAMPLES")
PRACTICAL EXAMPLES
>>> print("="*60)
============================================================

>>> print("\n1.Data Processing Example:")

1.Data Processing Example:
>>> print("-"*40)
----------------------------------------
>>> student_data = [
...     {"name": "Alice", "grades": [85,92,78,96]},
...     {"name": "Bob", "grades": [90,88,95,87]},
...     {"name": "Charlie", "grades": [70,75,80,72]},
...     {"name": "Diana", "grades": [95,98,92,94]}
... ]
>>> for student in student_data:
...     name=student["name"]
...     grades=student["grades"]
...     average=sum(grades)/len(grades)
...     print(f"{name}: {grades} -> {average:.1f}")
...
Alice: [85, 92, 78, 96] -> 87.8
Bob: [90, 88, 95, 87] -> 90.0
Charlie: [70, 75, 80, 72] -> 74.2
Diana: [95, 98, 92, 94] -> 94.8
>>> high_achievers=[s["name"] for s in student_data
...                if sum(s["grades"])/len(s["grades"])>85]
>>> print(f"High Achievers (>85): {high_achievers}")
High Achievers (>85): ['Alice', 'Bob', 'Diana']

>>> print("Text Anaysis Example:")
Text Anaysis Example:
>>> print("-"*40)
----------------------------------------
>>> text="Python is powerful programming language. Pythn is used for data science"
>>> text="Python is powerful programming language. Pythn is used for data science,web design,automation"
>>> words=text.lower().replace(",","").replace(".","").split()
>>> word_freq={}
>>> for word in words:
...     word_freq[word]=word_freq.get(word, 0)+1
...
>>> print("Word Frequency:")
Word Frequency:
>>> for word,count in sorted(word_freq.items()):
...     print(f" {word}: {count}")
...
 data: 1
 designautomation: 1
 for: 1
 is: 2
 language: 1
 powerful: 1
 programming: 1
 pythn: 1
 python: 1
 scienceweb: 1
 used: 1
>>> most_common=sorted(word_freq.items(),key=lambda x: x[1], reverse=True)[:3]
>>> print(f"Most Common Words: {most_common}")
Most Common Words: [('is', 2), ('python', 1), ('powerful', 1)]

>>> print("\n3.Set Operations Example:")

3.Set Operations Example:
>>> print("-"*40)
----------------------------------------
>>> group_a={"Alice","Bob","Charlie","Diana","Eve"}
>>> group_b={"Bob","Charlie","Frank","Grace","Henry"}
>>> print(f"Group A: {group_a}")
Group A: {'Bob', 'Charlie', 'Diana', 'Alice', 'Eve'}
>>> print(f"Group B: {group_b}")
Group B: {'Frank', 'Grace', 'Henry', 'Charlie', 'Bob'}
>>> both_groups=group_a & group_b
>>> only_a=group_a - group_b
>>> only_b=group_b - group_a
>>> all_students=group_a | group_b
>>> print(f"Students in both groups: {both_groups}")
Students in both groups: {'Charlie', 'Bob'}
>>> print(f"Students only in Group A: {only_a}")
Students only in Group A: {'Diana', 'Alice', 'Eve'}
>>> print(f"Students only in Group B: {only_b}")
Students only in Group B: {'Frank', 'Grace', 'Henry'}
>>> print(f"All Students: {all_students}")
All Students: {'Frank', 'Grace', 'Henry', 'Diana', 'Charlie', 'Bob', 'Alice', 'Eve'}

PERFORMANCE CONSIDERATIONS
>>> print("\n" + "="*60)

============================================================
>>> print("PERFORMANCE CONSIDERATIONS:")
PERFORMANCE CONSIDERATIONS:
>>> print("="*60)
============================================================
>>> print("""
... Collection Performance Characteristics:
... 1. LISTS:
...     -Access by index: 0(1)
...     -Search: 0(n)
...     -Insert/Delete at end: 0(1)
...     -Insert/Delete at beginning: 0(n)
... 2. TUPLES:
...     -Access by index: 0(1)
...     -Search: 0(n)
...     -Immutable (no insert/delete)
... 3. SETS:
...     -Add/Remove: 0(1) average
...     -Search: 0(1) average
...     -Union/Intersection: 0(n+m)
... 4.DICTIONARIES:
...     -Access by key: 0(1) average
...     -Add/Remove: 0(1) average
...     -Search: 0(1) average
... Choose the right collection for your use case!
... """)

Collection Performance Characteristics:
1. LISTS:
    -Access by index: 0(1)
    -Search: 0(n)
    -Insert/Delete at end: 0(1)
    -Insert/Delete at beginning: 0(n)
2. TUPLES:
    -Access by index: 0(1)
    -Search: 0(n)
    -Immutable (no insert/delete)
3. SETS:
    -Add/Remove: 0(1) average
    -Search: 0(1) average
    -Union/Intersection: 0(n+m)
4.DICTIONARIES:
    -Access by key: 0(1) average
    -Add/Remove: 0(1) average
    -Search: 0(1) average
Choose the right collection for your use case!

BEST PRACTICES:
>>> print("BEST PRACTICES")
BEST PRACTICES
>>> print("="*60)
============================================================
>>> print("""
... 1. COLLECTION SELECTION:
...     -Use lists for ordered, mutable sequences
...     -Use tuples for fixed, immutabe data
...     -Use sets for unique elements and fast membership testing
...     -Use dictionaries for key-value mappings
... 2. COMPREHENSIONS:
...     -Prefer comprehensions over loops for simple transformations
...     -Keep comprehensions readable - use multiple lines if needed
...     -Use generator expressions for large datasets
... 3. STRING OPERATIONS:
...     -Use f-strings for most formatting needs
...     -Use join() for concatenating multiple strings
...     -Be aware of string immutability
... 4. PERFORMANCE:
...     -Choose appropriate data structures
...     -Use built-in methods when possible
...     -Consider memory usage for large datasets
... 5. READABILITY:
...     -Use meaningful variable names
...     -Add comments for complex operations
...     -Follow PEP 8 style guidelines
... """)

1. COLLECTION SELECTION:
    -Use lists for ordered, mutable sequences
    -Use tuples for fixed, immutabe data
    -Use sets for unique elements and fast membership testing
    -Use dictionaries for key-value mappings
2. COMPREHENSIONS:
    -Prefer comprehensions over loops for simple transformations
    -Keep comprehensions readable - use multiple lines if needed
    -Use generator expressions for large datasets
3. STRING OPERATIONS:
    -Use f-strings for most formatting needs
    -Use join() for concatenating multiple strings
    -Be aware of string immutability
4. PERFORMANCE:
    -Choose appropriate data structures
    -Use built-in methods when possible
    -Consider memory usage for large datasets
5. READABILITY:
    -Use meaningful variable names
    -Add comments for complex operations
    -Follow PEP 8 style guidelines

>>> print("\n"+"="*60)

============================================================
>>> print("MODULE 2 COMPLETE!")
MODULE 2 COMPLETE!
>>> print("Next: Module 3 - Code Organisation,Functions & Error Handling")
Next: Module 3 - Code Organisation,Functions & Error Handling
>>> print("="*60)
============================================================