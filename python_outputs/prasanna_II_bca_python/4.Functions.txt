>>> print("Module 3: Code Organisation, Functions & Error Handling")
Module 3: Code Organisation, Functions & Error Handling
>>> print("="*60)
============================================================
>>> def add(x,y):
...     print("x is {} and y is {}".format(x,y))
...     return x+y
... add(5,6)
...
x is 5 and y is 6
11
>>> add(y=6, x=5)
x is 5 and y is 6
11
>>> def varargs(*args):
...     return args
... varargs(1,2,3)
...
(1, 2, 3)
>>> def keyword_args(**kwargs):
...     return kwargs
... keyword_args(big="foot",loch="ness")
...
{'big': 'foot', 'loch': 'ness'}
>>> def all_the_args(*args,**kwargs):
...     print(args)
...     print(kwargs)
... """
... all_the_args(1,2,a=3,b=4) prints:
...     (1,2)
...     {"a":3,"b":4}
... """
...
'\nall_the_args(1,2,a=3,b=4) prints:\n    (1,2)\n    {"a":3,"b":4}\n'
>>> args=(1,2,3,4)
>>> kwargs={"a":3,"b":4}
>>> all_the_args(*args)
(1, 2, 3, 4)
{}
>>> all_the_args(**kwargs)
()
{'a': 3, 'b': 4}
>>> all_the_args(*args,**kwargs)
(1, 2, 3, 4)
{'a': 3, 'b': 4}
>>> def swap(x,y):
...     return y,x
... x=1
... y=2
... x,y=swap(x,y)
... x=5
... def set_x(num):
...     x=num
...     print(x)
... def set_global_x(num):
...     global x
...     print(x)
...     x=num
...     print(x)
... set_x(43)
... set_global_x(6)
... """
... prints:
...     43
...     5
...     6
... """
...
43
5
6
'\nprints:\n    43\n    5\n    6\n'
>>> def create_adder(x):
...     def adder(y):
...         return x+y
...     return adder
... add_10=create_adder(10)
... add_10(3)
...
13
>>> def create_avg():
...     total=0
...     count=0
...     def avg(n):
...         nonlocal total, count
...         total+=n
...         count+=1
...         return total/count
...     return avg
... avg=create_avg()
... avg(3)
... avg(5)
... avg(7)
...
5.0
>>> (lambda x:x>2)(3)
True
>>> (lambda x,y:x**2+y**2)(2,1)
5
>>> list(map(add_10, [1,2,3]))
[11, 12, 13]
>>> list(map(max, [1,2,3],[4,2,1]))
[4, 2, 3]
>>> list(filter(lambda x: x>5,[3,4,5,6,7]))
[6, 7]
>>> [add_10(i) for i in [1,2,3]]
[11, 12, 13]
>>> [x for x in [3,4,5,6,7] if x > 5]
[6, 7]
>>> {x for x in "abcddeef" if x not in "abc"}
{'f', 'd', 'e'}
>>> {x: x**2 for x in range(5)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}


ADVANCED FUNCTION FEATURES:
>>> print("\n" + "="*60)

============================================================
>>> print("ADVANCED FUNCTION FEATURES")
ADVANCED FUNCTION FEATURES
>>> print("="*60)
============================================================
>>> def calculate_area(length: float,width: float) -> float:
...     """
...     Calculate the area of a rectangle.
...     Args:
...         length: The length of the rectangle
...         width: The width of the rectangle
...     Returns:
...         The area of the rectangle
...     """
...     return length*width
...
>>> def calculate_area(length: float,width: float) -> float:
...     """
...     Calculate the area of a rectangle.
...     Args:
...         length: The length of the rectangle
...         width: The width of the rectangle
...     Returns:
...         The area of the rectangle
...     """
...     return length*width
... def greet(name: str, greeting: str = "Hello", punctuation: str = "!"):
...     """Create a personalized greeting."""
...     return f"{greeting},{name}{punctuation}"
... print(f"Area: {calculate_area(5.0,3.0)}")
... print(f"Greeting: {greet('Alice')}")
... print(f"Custom greeting:{greet('Bob','Hi','!!!')}")
...
Area: 15.0
Greeting: Hello,Alice!
Custom greeting:Hi,Bob!!!

EXCEPTION HANDLING
>>> print("\n"+"="*60)

============================================================
>>> print("EXCEPTION HANDLING")
EXCEPTION HANDLING
>>> print("="*60)
============================================================
>>> def safe_divide(a: float, b: float) -> float:
...     """
...     Safely divise two numbers with error handling.
...     Args:
...         a: Dividend
...         b: Divisor
...     Returns:
...         Result of division
...     Raises:
...         ValueError: If divisor is zero
...         TypeError: If inputs are not numbers
...     """
...     try:
...         if not isinstance(a, (int,float)) or not isinstance(b, (int,float)):
...             raise TypeError("Both arguments must be numbers")
...         if b == 0:
...             raise ValueError("Cannot divide by zero")
...         return a/b
...     except(TypeError, ValueError) as e:
...         print(f"Error: {e}")
...         return None
...
>>> def safe_divide(a: float, b: float) -> float:
...     """
...     Safely divise two numbers with error handling.
...     Args:
...         a: Dividend
...         b: Divisor
...     Returns:
...         Result of division
...     Raises:
...         ValueError: If divisor is zero
...         TypeError: If inputs are not numbers
...     """
...     try:
...         if not isinstance(a, (int,float)) or not isinstance(b, (int,float)):
...             raise TypeError("Both arguments must be numbers")
...         if b == 0:
...             raise ValueError("Cannot divide by zero")
...         return a/b
...     except(TypeError, ValueError) as e:
...         print(f"Error: {e}")
...         return None
... print(f"10/3= {safe_divide(10,3)}")
... print(f"10/0= {safe_divide(10,0)}")
... print(f"'10'/3= {safe_divide('10',3)}")
...
10/3= 3.3333333333333335
Error: Cannot divide by zero
10/0= None
Error: Both arguments must be numbers
'10'/3= None

CONTEXT MANAGERS
>>> print("\n" + "="*60)

============================================================
>>> print("CONTEXT MANAGERS")
CONTEXT MANAGERS
>>> print("="*60)
============================================================
>>> class Timer:
...     """Context manager for timing code execution."""
...     def __init__(self, name: str = "Operation"):
...         self.name = name
...         self.start_time = None
...     def __enter__(self):
...         import time
...         self.start_time = time.time()
...         print(f"Starting {self.name}...")
...         return self
...     def __exit__(self, exc_type, exc_val, exc_tb):
...         import time
...         elapsed = time.time() - self.start_time
...         print(f"{self.name} completed in {elapsed:.4f} seconds")
... with Timer("List comprehension"):
...     squares = [x**2 for x in range(1000)]
...
Starting List comprehension...
List comprehension completed in 0.0005 seconds

DECORATORS
>>> print("\n" + "=" * 60)

============================================================
>>> print("DECORATORS")
DECORATORS
>>> print("="*60)
============================================================
>>> def timing_decorator(func):
...     """Decorator to time function execution."""
...     import time
...     import functools
...     @functools.wraps(func)
...     def wrapper(*args, **kwargs):
...         start_time = time.time()
...         result = func(*args, **kwargs)
...         elasped = time.time() - start_time
...         print(f"{func.__name__} executed in {elasped:.4f} seconds")
...     return wrapper
... @timing_decorator
... def slow_function(n: int) -> int:
...     """A function that takes some time to execute."""
...     import time
...     time.sleep(0.1)
...     return sum(range(n))
... result=slow_function(1000)
... print(f"Result: {result}")
...
slow_function executed in 0.1008 seconds
Result: None

GENERATOR FUNCTIONS
>>> print("\n" + "=" * 60)

============================================================
>>> print("GENERATOR FUNCTIONS")
GENERATOR FUNCTIONS
>>> print("="*60)
============================================================
>>> def fibonacci_generator(n:int):
...     """
...     Generate Fibonacci numbers upto n.
...     Args:
...         n: Maximum number of Fibonacci numbers to generate
...     Yeilds:
...         Fibonacci numbers
...     """
...     a , b = 0 , 1
...     count = 0
...     while count < n:
...         yield a
...         a , b = b , a + b
...         count += 1
... print("First 10 Fibonacci numbers:")
... for num in fibonacci_generator(10):
...     print(num, end=" ")
... print()
...
First 10 Fibonacci numbers:
0 1 1 2 3 5 8 13 21 34

MODULE CREATION EXAMPLE
>>> print("\n" + "=" * 60)

============================================================
>>> print("MODULE CREATION EXAMPLE")
MODULE CREATION EXAMPLE
>>> print("=" * 60)
============================================================
>>> class MathUtils:
...     """A Collection of mathematical utility functions."""
...     @staticmethod
...     def is_prime(n: int) -> bool:
...         """Check if a number is prime."""
...         if n < 2:
...             return False
...         for i in range(2, int(n ** 0.5) + 1):
...             if n % i == 0:
...                 return False
...         return True
...     @staticmethod
...     def factorial(n: int) -> int:
...         """Calculate factorial of n."""
...         if n < 0:
...             raise ValueError("Factorial is not defined for negative numbers.")
...         if n <= 1:
...             return 1
...         return n * MathUtils.factorial(n-1)
...     @staticmethod
...     def gcd(a: int, b: int) -> int:
...         """Calculate greatest common divisor."""
...         while b:
...             a, b = b, a % b
...         return a
... print(f"Is 17 prime? {MathUtils.is_prime(17)}")
... print(f"Factorial of 5: {MathUtils.factorial(5)}")
... print(f"GCD of 48 and 18: {MathUtils.gcd(48, 18)}")
...
Is 17 prime? True
Factorial of 5: 120
GCD of 48 and 18: 6

ERROR HANDLING BEST PRACTICES
>>> print("\n" + "=" * 60)

============================================================
>>> print("ERROR HANDLING BEST PRACTICES")
ERROR HANDLING BEST PRACTICES
>>> print("=" * 60)
============================================================
>>> class CustomError(Exception):
...     """Custom exception for our application."""
...     pass
... class ValidationError(CustomError):
...     """Raised when input validation fails."""
...     pass
... def validate_age(age: int) -> bool:
...     """validate age input."""
...     if not isinstance(age, int):
...         raise TypeError("Age must be an integer")
...     if age < 0:
...         raise ValidationError("Age cannot be negative")
...     if age > 150:
...         raise ValidationError("Age seems unrealistic.")
...     return True
... test_ages = [25, -5, 200, "thirty"]
... for age in test_ages:
...     try:
...         validate_age(age)
...         print(f"Age {age} is valid")
...     except ValidationError as e:
...         print(f"Validation error for age {age}: {e}")
...     except TypeError as e:
...         print(f"Type error for age {age}: {e}")
...
True
Age 25 is valid
Validation error for age -5: Age cannot be negative
Validation error for age 200: Age seems unrealistic.
Type error for age thirty: Age must be an intege

FUNCTIONAL PROGRAMMING CONCEPTS
>>> print("\n" + "=" * 60)

============================================================
>>> print("FUNCTIONAL PROGRAMMING CONCEPTS")
FUNCTIONAL PROGRAMMING CONCEPTS
>>> print("="*60)
============================================================
>>> def apply_operation(numbers: list, operation: callable) -> list:
...     """Apply an operation to a list of numbers."""
...     return [operation(x) for x in numbers]
... numbers = [1,2,3,4,5]
... squared = apply_operation(numbers, lambda x: x**2)
... cubed = apply_operation(numbers, lambda x: x**3)
... print(f"Numbers: {numbers}")
... print(f"Squared: {squared}")
... print(f"Cubed: {cubed}")
... def compose(f,g):
...     """Compose two functions."""
...     return lambda x: f(g(x))
... add_one = lambda x: x+1
... multiply_by_two = lambda x: x * 2
... add_one_then_double = compose(multiply_by_two, add_one)
... print(f"Composition result: {add_one_then_double}")
...
Numbers: [1, 2, 3, 4, 5]
Squared: [1, 4, 9, 16, 25]
Cubed: [1, 8, 27, 64, 125]
Composition result: <function compose.<locals>.<lambda> at 0x00000184B87A18A0>

BEST PRACTICES SUMMARY
>>> print("\n" + "=" * 60)

============================================================
>>> print("BEST PRACTICES SUMMARY")
BEST PRACTICES SUMMARY
>>> print("=" * 60)
============================================================
>>> print("""
... 1. FUNCTION DESIGN:
...     -Use descriptive names that indicate what the function does
...     -Keep functions small and focused on a single responsibility
...     -Use type hints for better code documentation
...     -Write comprehensive docstrings
... 2. PARAMETER HANDLING:
...     -Use default parameters for optional arguments
...     -Use *args and *kwargs or flexible function signatures
...     -Validate input parameters when neccessary
...     -Document parameters types and expected values
... 3. ERROR HANDLING:
...     -Use specific exception types
...     -Provide meaningful error messages
...     -Handle exceptions at the appropriate level
...     -Use context managers for resource management
... 4. CODE ORGANISATION:
...     -Group related functions into modules
...     -Use classes to organize related functionality
...     -Follow the DRY (Don't Repeat Yourself) principle
...     -Separate concerns into different modules
... 5. TESTING AND DEBUGGING:
...     -Write functions that are easy to test
...     -Use assetions fr debugging
...     -Handle edge cases appropriately
...     -Document expected behaviour and limitations
... """)

1. FUNCTION DESIGN:
    -Use descriptive names that indicate what the function does
    -Keep functions small and focused on a single responsibility
    -Use type hints for better code documentation
    -Write comprehensive docstrings
2. PARAMETER HANDLING:
    -Use default parameters for optional arguments
    -Use *args and *kwargs or flexible function signatures
    -Validate input parameters when neccessary
    -Document parameters types and expected values
3. ERROR HANDLING:
    -Use specific exception types
    -Provide meaningful error messages
    -Handle exceptions at the appropriate level
    -Use context managers for resource management
4. CODE ORGANISATION:
    -Group related functions into modules
    -Use classes to organize related functionality
    -Follow the DRY (Don't Repeat Yourself) principle
    -Separate concerns into different modules
5. TESTING AND DEBUGGING:
    -Write functions that are easy to test
    -Use assetions fr debugging
    -Handle edge cases appropriately
    -Document expected behaviour and limitations

>>> print("\n" + "=" * 60)

============================================================
>>> print("MODULE 3 COMPLETE!")
MODULE 3 COMPLETE!
>>> print("Next: Module 4 - Python Progams & Filesystem Interaction")
Next: Module 4 - Python Progams & Filesystem Interaction
>>> print("="*60)
============================================================